\documentclass[a4paper,11pt,oneside]{article}

\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}

\usepackage[bookmarks,colorlinks]{hyperref}
\usepackage{enumerate}
\usepackage[dvipsnames]{xcolor}
\usepackage{soulutf8}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}

\definecolor{hlcolor}{RGB}{253,241,98}
\sethlcolor{hlcolor}

\theoremstyle{plain}
\newtheorem{lem}{Lemma}[section]
\newtheorem{prop}{Proposizione}[section]
\newtheorem{thm}{Teorema}[section]

\theoremstyle{definition}
\newtheorem{defn}{Definizione}[section]

\theoremstyle{remark}
\newtheorem*{esempio}{Esempio}
\newtheorem*{nota}{Nota}

\newcommand{\mhl}[1]{\colorbox{hlcolor}{$\displaystyle #1$}}

\title{Appunti di ``Algoritmi e Principi dell'informatica''}
\author{Alexandru Gabriel Bradatan}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduzione ai modelli}\label{sec:modelli}

I modelli sono fondamentali nell'ingegneria. I modelli sono talvolta fisici e
spesso sono \hl{modelli formali, ossia oggetti matematici che fungono da
rappresentazioni astratte di entità reali complesse.} Un modello è \hl{adeguato
se i risultati ottenuti riflettono le proprietà che ci interessano del sistema
fisico entro i limiti della nostra approssimazione.} I modelli dell'informatica
si basano principalmente sulla matematica discreta. Definiamo i due tipi di
modelli che costruiremo.

\begin{defn}[\hl{Modello operazionale}]\label{def:modello-op}
  È un modello basato sul concetto di stato e di meccanismo per la sua
  evoluzione.
\end{defn}

\begin{defn}[\hl{Modello descrittivo}]\label{def:modello-desc}
  È un modello che formula le proprietà desiderate o no dal sistema piuttosto
  che il suo funzionamento.
\end{defn}

\hl{Le differenze tra questi due tipi di modellizzazione non sono spesso molto
ben definite.}

\begin{esempio}
  Modellizziamo lo stesso problema, l'ordinamento di una sequenza di interi,
  secondo i due criteri enunciati sopra:
  \begin{itemize}
    \item Modello operazionale: Calcola il minimo in tutto l'array e mettilo al
      primo posto. Continua ad eseguire l'operazione finché l'array non è in
      ordine.
    \item Modello descrittivo: Individua una permutazione degli elementi
      dell'array tale che \(\forall i a[i] \leq a[i+1]\).
  \end{itemize}
\end{esempio}

\hl{Le fasi dell'ingegneria del software ricalcano quelli della modellizzazione
di un problema:}

\begin{itemize}
  \item Analisi dei requisiti: Stesura della specifica del sistema
  \item Progetto: Architettura del software
  \item Implementazione: Scrittura effettiva del codice
\end{itemize}

\section{I linguaggi}\label{sec:linguaggi}

Il \hl{meta-modello fondamentale che useremo sarà il linguaggio}. Il termine
linguaggio è un termine che conosciamo già ed è utilizzabile a diversi ambiti
diversi come la linguistica, l'informatica, la grafica e la musica.

\subsection{Costruzione di un linguaggio}\label{sec:linguaggi-costruzione}

Iniziamo a definire i vari elementi un linguaggio. Il \hl{primo elemento formale
di un linguaggio è l'alfabeto o vocabolario}. In matematica essi sono sinonimi
anche se in italiano naturale non lo sono.

\begin{defn}[\hl{Alfabeto}]\label{def:alfabeto}
  Si dice alfabeto un insieme finito $A$ di simboli base.
\end{defn}

Una volta definito il concetto di alfabeto possiamo anche definire il concetto
di \hl{stringa}.

\begin{defn}[\hl{Stringa}]\label{def:stringa}
  Si dice stringa una sequenza ordinata e finita di elementi dell'alfabeto $A$.
\end{defn}

Naturalmente ogni stringa possiede una \hl{lunghezza $|a|$ pari al numero di
elementi dell'alfabeto contenuti al suo interno}. Definiamo anche la \hl{stringa
nulla $\epsilon$ tale che $|\epsilon|=0$}. Definiamo infine \hl{$A^\star$
l'insieme di tutte le stringhe scrivibili con un certo alfabeto}.

\begin{nota}
  L'operatore \hl{$\star$ è detto stella, star, iterazione o stella di Kleene.}
  L'insieme $A^\star$ è infinito numerabile.
\end{nota}

Sulle stringhe possiamo definire l'operazione di \hl{concatenazione}:

\begin{defn}[\hl{Concatenazione di stringhe}]\label{def:concatenazione-stringhe}
  \begin{equation}
    \begin{array}{cccc}
      . : & A^\star \times A^\star & \to & A^\star \\
          & (x, y) & \mapsto & x.y
    \end{array}
  \end{equation}
\end{defn}

\begin{nota}
  La scrittura dell'operatore di concatenazione può essere omessa, scrivendo al
  posto di $z = x.y$ $z = xy$.
\end{nota}

L'operazione di concatenazione gode della proprietà \hl{associativa ma non della
commutativa} e ha come \hl{elemento neutro la stringa vuota}. Possiamo quindi
definire il \hl{monoide non commutativo delle stringhe rispetto alla
concatenazione $\langle A^\star, . \rangle$}.

Definito tutti questi elementi possiamo finalmente definire un \hl{linguaggio}.

\begin{defn}[\hl{Linguaggio}]\label{def:linguaggio}
  Chiamiamo un linguaggio un insieme $L$ tale che: $L \subseteq A^\star$.
\end{defn}

Notiamo che \hl{$L$ può anche essere infinito}. Inoltre, poiché $L$ è un
insieme, le \hl{operazioni insiemistiche sono tutte ben definite.} Un
\hl{insieme di linguaggi che condividono le stesso proprietà è detto famiglia di
linguaggi}.

\subsection{Operazioni sui linguaggi}

\begin{defn}[\hl{Concatenazione di linguaggi}]\label{def:concatenazione-ling}
  \begin{equation}
    L_1 . L_2 = \{ x.y : x \in L_1, y \in L_2 \}
  \end{equation}
\end{defn}

\begin{defn}[\hl{Potenze di linguaggi}]\label{def:potenze-linguaggi}
  \begin{equation}
    \begin{aligned}
      L^0 & = \{\epsilon\} \\
      L^i & = L^{i-1}.L
    \end{aligned}
  \end{equation}
\end{defn}

\begin{defn}[\hl{Star (Linguaggi)}]\label{def:star-linguaggi}
  \begin{equation}
    L^\star = \bigcup^{\infty}_{i=0} L^i
  \end{equation}
\end{defn}

\begin{defn}[\hl{Plus (Linguaggi)}]\label{def:plus-linguaggi}
  \begin{equation}
    L^+ = \bigcup^{\infty}_{i=1} L^i
  \end{equation}
\end{defn}

\begin{nota}
  La differenza tra scrivere $L^\star$ e $L^+$ è che in $L^+$ è assente il
  linguaggio vuoto!
\end{nota}

\subsection{A cosa utilizzeremo i linguaggi?}

Il nostro \hl{principale utilizzo del concetto di linguaggio sarà per definire
in maniera astratta il concetto di problema informatico}. Il nostro \hl{primo}
problema informatico sarà:

\begin{equation}
  \mhl{ x \in A^\star, L \subseteq A^\star \quad  x \in L? }
\end{equation}

Questa semplice questione è capace di modellizzare una grande varietà di
problemi diversi, scelti $A$ ed $L$ in modo adatto. Un \hl{secondo} problema sarà
quello di \hl{trovare una traduzione}, ossia una funzione così definita:

\begin{defn}[\hl{Traduzione}]\label{def:traduzione}
  \begin{equation}
    \begin{array}{cccc}
      \tau: & L_1 & \to     & L_2 \\
            & x   & \mapsto & \tau(x)
    \end{array}
  \end{equation}
\end{defn}

\section{Modelli operazionali}\label{sec:modelli-operazionali}

\subsection{Automi a stati finiti}\label{sec:fsa}

Gli \hl{automi a stati finiti (FSA) sono il modello operazionale più semplice}.
Essi sono caratterizzati da un \hl{insieme finito di stati e da un insieme di
regole di transizione}. Gli \hl{stati} possono essere di \hl{accettazione o no}.
Le \hl{regole di transizione permettono al nostro automa di passare da uno stato
all'altro in base a ciò che forniamo come input}. Quando un automa riceve un
\hl{input lo elabora e produce un output. L'elaborazione inizia in uno stato
iniziale e consiste nel leggere l'input e spostarsi da uno stato all'altro
secondo le leggi di transizione}. \hl{Se alla fine} della lettura l'automa
\hl{si trova in uno stato di accettazione, diremo che esso ha accettato l'input,
altrimenti diremo che l'ha rifiutato}.

\begin{defn}[\hl{Automa a stati finiti}]\label{def:fsa}
  Un automa a stati finiti $\mathcal{A}$ è una quintupla
  $\langle Q, I, \delta, q_0, F \rangle$ dove:
  \begin{enumerate}
    \item $Q$ è l'insieme finito non vuoto di tutti gli stati
    \item $I$ è l'alfabeto di ingresso
    \item $\delta: Q \times I \to Q$ è la funzione (relazione) di transizione
    \item $q_0 \in Q$ è lo stato iniziale
    \item $F \subseteq Q$ è l'insieme degli stati di accettazione
  \end{enumerate}
\end{defn}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial,accepting]  (q0)                {$q_0$};
    \node[state]                    (q1) [right of=q0]  {$q_1$};

    \path[->]
    (q0) edge                node {0,1}  (q1)
    (q1) edge  [loop above]  node {0,1}  ();
  \end{tikzpicture}
  \caption{Esempio di diagramma di stato di FSA}\label{fig:fsa-diagramma-stato}
\end{figure}

Se \hl{$\delta$ è una funzione l'automa si dice completo, altrimenti non
completo}.  Gli \hl{automi non completi} possono facilmente \hl{resi completi
``riempiendo'' le transizioni mancanti con delle transizioni verso uno stato di
``sink'' dal quale non si può più uscire}.

Un automa \hl{processa l'input tramite una sequenza di transizioni di stato
effettuate iterando su ogni carattere della stringa e muovendosi allo stato
corrispondente a $\delta(q, i)$}. Definiamo formalmente la sequenza di mosse
eseguita da un automa a stati finiti.

\begin{defn}[\hl{Sequenza di mosse}]\label{def:fsa-seq-mosse}
  Sia un FSA $\mathcal{A}$, la sequenza di mosse è una funzione

  \begin{equation}
    \delta^\star: Q \times I^\star \to Q
  \end{equation}

  Definita induttivamente da:

  \begin{enumerate}
    \item $\delta^\star(q, \epsilon) = q$
    \item $\delta^\star(q, y.i) = \delta(\delta^\star(q,y), i)$ con
      $y \in I^\star, i \in I$
  \end{enumerate}
\end{defn}

Gli \hl{FSA rappresentano dei linguaggi}, più nello specifico la famiglia dei
\hl{linguaggi regolari} ($\mathbf{REG}$). Se \hl{$L$ è un linguaggio accettato}
da $\mathcal{A}$ allora diremo che esso è il \hl{linguaggio di $\mathcal{A}$ e
lo indichiamo come $L(\mathcal{A})$}. Usando la definizione di \hl{sequenza di
mosse possiamo scrivere $L(\mathcal{A})$ come}:

\begin{equation}
  L(\mathcal{A}) = \{ x \in I^\star : \delta^\star(q_0, x) \in F \}
\end{equation}

Per \hl{rappresentare il linguaggio} accettato da un FSA possiamo usare la pura
notazione insiemistica oppure, visto che i linguaggi sono regolari, delle
\hl{espressioni regolari}. Definiamo la sintassi delle espressioni regolari.

\begin{defn}[Espressioni regolari]\label{def:regex}
  Dato una alfabeto $A$, siano le seguenti operazioni:

  \begin{itemize}
    \item $R + S = R \cup S$ con $R \subseteq A^\star$ e $S \subseteq A^\star$
    \item $\star$ la star di Kleene:
      $R^\star = \{x^n : n \in \mathbb{N}, x \in R\}$
    \item $R^+ = \{x^n : n \in \mathbb{N}^*, x \in R\}$
    \item la concatenazione: $RS = \{xy : x \in R, y \in S\}$
  \end{itemize}

  Allora, dato un alfabeto $A$ e un insieme di simboli
  $\{+,\star,(,),.,\emptyset\}$ si dice espressione regolare su $A$ la stringa
  $R \in A \cup \{+,\star,(,),.,\emptyset\}$ che rende vera una delle seguenti
  condizioni:

  \begin{enumerate}
    \item $R = \emptyset$
    \item $R \in A$
    \item $R = S + T$, $R = ST$, $R = S^\star$, $R = S^+$ con $S,T$ espressioni
      regolari su $A$
  \end{enumerate}
\end{defn}

Gli \hl{automi a stato finito sono modelli di calcolo con una memoria finita
pari al numero di stati}. Infatti \hl{ogni stato} rappresenta una \hl{istantanea
della situazione in cui si trova il sistema in un dato istante}. Il fatto di
\hl{possedere una memoria finita}, come vedremo in~\ref{sec:fsa-analisi}, è uno
degli \hl{aspetti più limitanti} degli automi a stato finito e ci costringeranno
a costruire modelli più sofisticati.

\subsubsection{Automi a stati finiti traduttori}\label{sec:fsa-trad}

Un FSA può anche essere \hl{usato come traduttore tra un linguaggio ed un
altro}. Ci basta \hl{aggiungere la capacità di dare un output} al nostro automa.

Un semplice FSA si limita semplicemente ad interpretare un input senza produrre
nessun output. Se ad un \hl{FSA} aggiungiamo la possibilità di \hl{produrre un
output} otteniamo un \hl{trasduttore}. Un \hl{particolare tipo} di trasduttore
che ci interessa è il \hl{traduttore}.

Prima di parlare di traduttori, però, formalizziamo come un automa produce un
output.

\begin{defn}[\hl{Funzione di transizione con uscita}]\label{def:fsa-transizione-uscita}
  Chiamiamo $\delta(q, i/w)$ con $i \in I$ e $w \in O$, $I, O$ alfabeti, una
  funzione di transizione tra stati che restituisce il nuovo stato del FSA e
  un simbolo complesso $w$.
\end{defn}

Ora possiamo definire il traduttore.

\begin{defn}[\hl{Automa a stati finiti traduttore}]\label{def:fsa-trad}
  Sia $\mathcal{A} = \langle Q, I, \delta, q_0, F \rangle $ un automa a stati
  finiti con funzione di transizione $\delta(q, i/w)$, definiamo automa a
  stati finiti traduttore $\mathcal{T}$ la terna
  $\langle \mathcal{A}, O, \eta \rangle$ dove:

  \begin{itemize}
    \item $O$ è l'alfabeto di uscita di $\delta$
    \item $\eta : Q \times I \to O^\star$ funzione di traduzione
  \end{itemize}
\end{defn}

\hl{Analogamente a quanto fatto in}~\ref{def:fsa-seq-mosse} \hl{possiamo
iterare} la funzione di traduzione usando la stella di Kleene, così da \hl{poter
finalmente enunciare la traduzione come}:

\begin{equation}
  \mhl{\tau(x) = \eta^\star(q_0, x)}
\end{equation}

Se il \hl{traduttore conclude} la propria esecuzione \hl{su uno stato di
accettazione}, allora possiamo dire che la \hl{stringa di input e corretta e la
sua traduzione nel linguaggio di output è $\tau(x)$}.

\subsubsection{Analisi degli automi a stati finiti}\label{sec:fsa-analisi}

Gli automi a stati finiti sono un modello molto semplice ed intuitivo, applicato
a molti settori. Abbiamo già visto in~\ref{sec:fsa} che sono adatti a modellare
linguaggi regolari e che sono modelli a memoria finita. Studiamone ora nel
dettaglio le proprietà ed eventuali limitazioni.

Innanzitutto esiste qualche \hl{condizione affinché un automa a stati finiti sia
o no accettore di un linguaggi finito o infinito} (il caso di linguaggio vuoto è
banale)? Si dimostra che \hl{esistono} due condizioni \hl{necessarie e
sufficienti} per l'accettazione dei linguaggi, \hl{una per il caso finito e un
per l'infinito}.

\begin{thm}[\hl{Condizione di accettazione di un linguaggio finito}]\label{thm:accettazione-ling-finito}
  Condizione sufficiente e necessaria affinché un automa a stati finiti accetti
  un linguaggio finito non vuoto è che possa accettare una stringa di lunghezza
  inferiore al numero di stati ($|x| < |Q|$).
\end{thm}

\begin{thm}[\hl{Condizione di accettazione di un linguaggio infinito}]\label{thm:accettazione-ling-infinito}
  Condizione sufficiente e necessaria affinché un automa a stati finiti accetti
  un linguaggio infinito è che possa accettare una stringa tale che:
  $|Q| \leq |x| < 2|Q|$
\end{thm}

Questo teorema deriva dall'osservazione che \hl{se un automa accetta un
linguaggio infinito, nel suo grafo saranno presenti dei cicli che potranno
essere percorsi un numero arbitrario di volte}. Nel \hl{caso peggiore} verranno
\hl{ripercorsi tutti gli stati} dell'automa \hl{tranne l'ultimo} che deve essere
di accettazione.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]            (q0)                {$q_0$};
    \node[state]                    (q1) [right of=q0]  {$q_1$};
    \node[state]                    (q2) [right of=q1]  {$q_2$};
    \node[state]                    (q3) [right of=q2]  {$q_3$};
    \node[state]                    (q4) [right of=q3]  {$q_4$};
    \node[state,accepting]          (q5) [right of=q4]  {$q_5$};

    \path[->]
    (q0) edge                node {} (q1)
    (q1) edge                node {} (q2)
    (q2) edge                node {} (q3)
    (q3) edge                node {} (q4)
    (q4) edge                node {} (q5)
    (q5) edge  [bend left]   node {} (q0);
  \end{tikzpicture}
  \caption{Peggior caso del teorema~\ref{thm:accettazione-ling-infinito}}\label{fig:fsa-accettazione-ling-infinito}
\end{figure}

Possiamo quindi vedere \hl{una stringa di un linguaggio infinito come composta
da 3 parti: un preambolo al ciclo, il ciclo e l'epilogo}. Il ciclo può ripetersi
un numero infinito di volte, generando la seguente espressione regolare:

\begin{equation}
  \mhl{x = x_i x_c^\star x_f}
\end{equation}

Questa è una \hl{condizione necessaria affinché una stringa di un linguaggio
infinito sia riconosciuta da un FSA} e rappresenta il \hl{contenuto del
``Pumping lemma''}:

\begin{lem}[\hl{Pumping lemma}]\label{thm:pumping-lemma}
  Sia un automa a stati finiti $\mathcal{A}$ che accetta un linguaggio
  $L(\mathcal{A})$. Allora per ogni $x \in L$ con $|x| > |Q|$ esiste $q \in Q$
  e $w \in I^+$ tali da verificare una di queste condizioni:

  \begin{itemize}
    \item $x = ywz$
    \item $\delta^\star(q,w) = q$
  \end{itemize}

  Come conseguenza si ha: $\forall n \in \mathbb{N} \geq 0, y w^n z \in L$
\end{lem}

Il Pumping lemma, quindi, ci \hl{mette dei paletti sui tipi di linguaggi
infiniti che un FSA può accettare}. Infatti consideriamo il seguente linguaggio
infinito:

\begin{equation}
  \mhl{L = \{ a^n b^n : n \in \mathbb{N} \}}
\end{equation}

\hl{Supponiamo} che un \hl{FSA sia in grado di accettarlo}, allora consideriamo
la stringa \hl{$x = a^m b^m$ con $m > |Q|$} e applichiamo il \hl{Pumping lemma}.
Otterremo \hl{3 casi possibili}:

\begin{enumerate}
  \item \hl{$w = a^p$} e quindi dovrebbe essere:
    \[
      \mhl{
      x = a^m b^m = a^r a^p a^s b^m = a^r w a^s b^m \in L \text{ con } r+p+s=m
    }
    \]
    \hl{Se il Pumping lemma dovesse valere}, allora si dovrebbe avere che
    \hl{$a^r w^k b^m \in L$} che ci porta ad un \hl{assurdo}.
  \item \hl{$w = b^p$ analogo al precedente}.
  \item \hl{$w = a^p b^q$} e quindi dovrebbe essere:
    \[
      \mhl{
      x = a^m b^m = a^r a^p b^q b^s = a^r w b^s \in L \text{ con } r+p=q+s=m
      }
    \]
    \hl{Se il Pumping lemma dovesse valere}, allora si dovrebbe avere che
    \hl{$a^r w^k b^s \in L$} che ci porta ad un \hl{assurdo}.
\end{enumerate}

Ciò significa che \hl{considerare $L$ come accettato da una FSA è un assurdo}.
Il linguaggio $L$ appena costruito ci dimostra quindi la necessità di costruire
modelli di calcolo più potenti. \hl{Infatti per contare fino a $n$ non basta la
memoria finita degli FSA ma servirebbe una memoria infinita!}

\subsubsection{Proprietà di chiusura degli automi a stati finiti}\label{sec:chiusura-fsa}

Il concetto di chiusura di un insieme rispetto ad un'operazione o proprietà è
un concetto già affrontato nel precedente corso di logica e algebra lineare. In
questo contesto ci occupiamo della \hl{chiusura della famiglia dei linguaggi
regolari}.

\hl{La famiglia dei linguaggi regolari è chiusa rispetto a tutte le operazioni
insiemistiche, alla concatenazione, alla star di Kleene e praticamente tutte le
altre viste fino ad ora.} Proviamo a costruirne qualcuno.

\paragraph{Intersezione} Proviamo a costruire l'intersezione di due automi. Il
risultato sarà un automa che \hl{accetta solo stringe solo stringhe accettate da
entrambi gli automi di partenza}. Dati i due automi di partenza:

\[
  \begin{aligned}
    A^1 &= \langle Q^1, I, \delta^1, q_0^1, F^1 \rangle \\
    A^2 &= \langle Q^2, I, \delta^2, q_0^2, F^2 \rangle
  \end{aligned}
\]

Possiamo scrivere l'automa intersezione come:

\begin{gather}
  \langle A^1, A^2 \rangle = \langle Q^1 \times Q^2, I, \delta,
    \langle q_0^1, q_0^2 \rangle, F^1 \times F^2 \rangle\label{eqn:automa-intersezione} \\
  \delta(\langle q^1, q^2 \rangle, i) = \langle \delta(q^1, i),
    \delta(q^2, i) \rangle
\end{gather}

Con una semplice induzione si può dimostrare che il linguaggio di un automa così
definito è $L(\langle A^1, A^2 \rangle) = L(A^1) \cap L(A^2)$.

\begin{figure}[htb]
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]   (q0) {$q_0$};
    \node[state]           (q1) [right of=q0] {$q_1$};
    \node[state]           (q2) [right of=q1] {$q_2$};
    \node[state,accepting] (q3) [right of=q2] {$q_3$};
    \node[] (t) [left=1.5cm of q0] {$A^1$:};

    \path[->]
      (q0) edge node {$b$} (q1)
      (q1) edge node {$a$} (q2)
      (q2) edge node {$a$} (q3);
  \end{tikzpicture}
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]   (p0) {$p_0$};
    \node[state]           (p1) [right of=p0] {$p_1$};
    \node[state]           (p2) [right of=p1] {$p_2$};
    \node[state,accepting] (p3) [right of=p2] {$p_3$};
    \node[] (t) [left=1.5cm of p0] {$A^2$:};

    \path[->]
      (p0) edge node {$b$} (p1)
      (p1) edge node {$a$} (p2)
      (p2) edge node {$a$} (p3);
  \end{tikzpicture}
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0) {$\langle q_0, p_0 \rangle$};
    \node[state]           (q1) [right of=q0] {$\langle q_1, p_1 \rangle$};
    \node[state]           (q2) [right of=q1] {$\langle q_2, p_2 \rangle$};
    \node[state,accepting] (q3) [right of=q2] {$\langle q_3, p_3 \rangle$};
    \node[] (t) [left=1.5cm of q0] {$\langle A^1, A^2 \rangle$:};

    \path[->]
      (q0) edge node {$b$} (q1)
      (q1) edge node {$a$} (q2)
      (q2) edge node {$a$} (q3);
  \end{tikzpicture}
  \centering
  \caption{Due automi e la loro intersezione}%
  \label{fig:esempio-automa-intersezione}
\end{figure}

\paragraph{Unione} Per l'unione il tutto funziona in \hl{modo analogo}. L'automa
risultante sarà un automa che \hl{accetterà stringhe accettate da almeno uno dei due
automi di partenza}. Eseguendo un procedimento simile a quello effettuato per
ottenere~\ref{eqn:automa-intersezione} abbiamo:

\begin{equation}
  \langle A^1, A^2 \rangle = \langle Q^1 \times Q^2, I, \delta,
    \langle q_0^1, q_0^2 \rangle, F^1 \times Q^2 \cup Q^1 \times F^2 \rangle
\end{equation}

Questo approccio presenta, però, un \hl{problema}: \hl{non funziona se l'automa
di partenza non è completo}. Con l'intersezione non avevamo problemi perché
l'automa intersezione accettava solo stringhe accettate da entrambi gli automi
iniziali, rimuovendo il problema della non completezza. Con l'unione invece
otterremo un automa che accetta anche quando uno degli automi iniziali non
accetta, rendendo problematico il caso di un errore dovuto alla parzialità della
funzione di transizione. \hl{Bisogna, quindi, ricordarsi di completare gli
automi aggiungendo eventuali stati di errore prima di eseguirne l'unione}.

\paragraph{Complemento} Per il complemento la situazione è \hl{analoga all'unione}:
anche qui dobbiamo stare attenti alla completezza dei due automi di partenza.
L'automa complemento sarà praticamente uguale all'automa di partenza, solo che
\hl{gli stati di accettazione ora saranno di non accettazione e viceversa}.

\begin{equation}
  \neg A = \langle Q, I, \delta, q_0, Q \setminus F \rangle
\end{equation}

\subsection{Automi a stati finiti con pila}\label{sec:pda}

Arricchiamo ora i nostri automi a stati finiti con della \hl{memoria}. Questa
memoria sarà \hl{strutturata come una pila (stack)} di dimensione potenzialmente
illimitata. L'automa può \hl{manipolare la pila tramite le due operazioni
fondamentali} delle pile: \hl{push e pop}. L'automa così strutturato si chiama
``automa a pila'', in breve PDA (dall'inglese ``Push Down Automata'').
Indicheremo convenzionalmente \hl{l'inizio della pila con $Z_0$}.

A grandi linee, una \hl{mossa} dell'automa a pila è \hl{strutturata in diversi
passi}:

\begin{enumerate}
  \item \hl{Leggi un simbolo (o nulla) dall'input} (d'ora in poi lo chiameremo
    nastro d'ingresso)
  \item Esegui una \hl{pop di un elemento} dalla stack
  \item \hl{Cambia stato}
  \item Sposta di una posizione il puntatore del carattere corrente (la testina
    del nastro d'ingresso)
  \item Esegui una \hl{push di una serie di caratteri (anche nulla)}
  \item Se è un automa traduttore, \hl{scrivi una stringa (anche nulla)
    sull'output} (nastro d'uscita)
\end{enumerate}

Come per gli FSA, \hl{la stringa in ingresso viene riconosciuta se l'automa la
scandisce completamente e termina su uno stato di accettazione}. Lo stato della
\hl{pila non è rilevante}. Se l'automa è \hl{traduttore}, allora \hl{se accetta}
la stringa \hl{l'output corrisponde alla stringa tradotta, altrimenti} viene
detta \hl{indefinita} e lo indichiamo con \hl{$\tau(x) = \bot$}. In generale
useremo il simbolo $\bot$ anche con la funzione $\delta$ per indicare una
transizione indefinita.

Poiché le transizioni di stato sono più ricche di quelle degli FSA, dobbiamo
adottare una \hl{notazione ben definita per indicare le varie azioni compiute}:

\begin{equation}
  \mhl{a, A / B\ldots, c}
\end{equation}

\begin{itemize}
  \item \hl{$a$} il carattere \hl{letto in input}
  \item \hl{$A$} il carattere \hl{letto dalla pila tramite stack}
  \item \hl{$B\ldots$} i caratteri \hl{reinseriti nella pila} tramite la push
  \item \hl{$c$} il carattere \hl{scritto sull'output}
\end{itemize}

Nel caso in cui l'automa \hl{non leggesse nulla} dal nastro d'ingresso diciamo
che l'automa \hl{ha effettuato una $\epsilon$-mossa} e la indichiamo
\hl{riportando $\epsilon$ come carattere letto} dal nastro d'ingresso. Vale
\hl{lo stesso anche con il carattere della push}.

\begin{nota}
  Un automa a pila \hl{non può non leggere nessun carattere dalla pila!}
  Scrivere, quindi, \hl{$a, \epsilon/B$ è sbagliato}.
\end{nota}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0) []            {$q_0$};
    \node[state]           (q1) [right of=q0] {$q_1$};
    \node[state]           (q2) [right of=q1] {$q_2$};
    \node[state,accepting] (q3) [right of=q2] {$q_3$};

    \path[->]
    (q0) edge              node {$a, Z_0/Z_0 A$} (q1)
    (q1) edge [loop above] node {$a, A/AA$} ()
    (q1) edge              node {$b, A/\epsilon$} (q2)
    (q2) edge [loop above] node {$b, A/\epsilon$} ()
    (q2) edge              node {$\epsilon, Z_0/\epsilon$} (q3);
  \end{tikzpicture}
  \caption{Esempio di un automa a pila}%
  \label{fig:automa-pila}
\end{figure}

Formalizziamo ora i concetti introdotti.

\begin{defn}[\hl{Automa a stati finiti a pila}]\label{defn:automa-pila}
  Definiamo un automa a stati finiti con pila $\mathcal{A}$ una eptupla
  $\langle I, \Gamma, \delta, q_0, Z_0, F \rangle$ dove:

  \begin{itemize}
    \item $Q, I, q_0, F$ sono definiti alla stessa maniera di un FSA
    \item $\Gamma$ è l'alfabeto di pila
    \item $Z_0$ è il simbolo iniziale di pila
    \item
      $\delta: Q \times (I \cup \epsilon) \times \Gamma \to Q \times \Gamma^\star$
      è la funzione di transizione
  \end{itemize}
\end{defn}

\begin{defn}[\hl{Automa a stati finiti a pila traduttore}]\label{defn:automa-pila-trad}
  Definiamo un automa a stati finiti con pila $\mathcal{A}$ una ennupla
  $\langle I, \Gamma, \delta, q_0, Z_0, F, 0, \eta \rangle$ dove:

  \begin{itemize}
    \item $Q, I, q_0, F, O$ sono definiti alla stessa maniera di un FSA
    \item $\Gamma$ è l'alfabeto di pila
    \item $Z_0$ è il simbolo iniziale di pila
    \item
      $\delta: Q \times (I \cup \epsilon) \times \Gamma \to Q \times \Gamma^\star$
      è la funzione di transizione
    \item $\eta: Q \times (I \cup \epsilon) \times \Gamma \to O^\star$ è la
      funzione di traduzione
  \end{itemize}
\end{defn}

\begin{nota}
  La funzione $\eta$ è definita ovunque lo è anche $\delta$.
\end{nota}

La funzione di \hl{$\delta$ deve essere parziale} perché l'esistenza delle
\hl{$\epsilon$-mosse causerebbe non-determinismo} in caso di completezza
dell'automa: \hl{non possono esistere una $\epsilon$-mossa tra due stati $q, q'$
se tra questi due stati esiste già un'altra mossa che legge lo stesso simbolo
dalla pila}. Un automa a stati finiti non può decidere deterministicamente tra
una $\epsilon$-mossa e una regolare. Ciò che abbiamo detto fino ad ora può
essere formalizzato come:

\begin{equation}
  \mhl{
  \forall q, A \delta(q, \epsilon, A) \neq \bot \implies
    \forall i \delta(q,i,A) = \bot
  }
\end{equation}

Il concetto intuitivo di stato che avevamo introdotto con gli FSA oramai non è
più adeguato in quanto è troppo semplicistico. Negli automi a pila, infatti, si
aggiunge anche lo stato della pila che anch'esso contribuisce allo stato
generale dell'automa. Formalizziamo, quindi, \hl{la generalizzazione dello
stato: la configurazione}.

\begin{defn}[Configurazione]\label{def:configurazione}
  Chiamiamo configurazione di un automa a pila la tripla (se traduttore
  quadrupla) $c = \langle q, x \gamma \rangle$
  ($\langle q, x \gamma, z \rangle$) dove:

  \begin{itemize}
    \item $q \in Q$ è lo stato dell'organo di controllo
    \item $x$ è la stringa ancora da leggere nel nastro d'ingresso
    \item $\gamma$ è la stringa di caratteri nella pila (rappresentati usando la
      convenzione ``alto-destra basso-sinistra'')
    \item $z$ la stringa già scritta sul nastro di uscita
  \end{itemize}
\end{defn}

Tra le configurazioni di un automa a pila è presente una \hl{relazione di
transizione indicata con $\vdash$}. Possiamo esprimere il passaggio di stato
come:

\begin{equation}
  \mhl{
  c = \langle q, x, \gamma \rangle \vdash c' = \langle q', x', \gamma' \rangle
  }
\end{equation}

Indichiamo con \hl{$\vdash^\star$ la chiusura transitiva e riflessiva di $\vdash$}. Essa
non è altro che l'insieme delle nostre \hl{vecchie sequenze di mosse}. Usando
$\vdash^\star$ possiamo anche \hl{formalizzare l'accettazione di una stringa} (e la sua
eventuale traduzione) come:

\begin{equation}
  c_0 = \langle q_0, x, Z_0, (\epsilon) \rangle \vdash^\star
    c_f = \langle q, \epsilon, \gamma , (z) \rangle
\end{equation}

\begin{nota}
  D'ora in poi indicheremo la chiusura transitiva e riflessiva di una relazione
  $A$ con $A^\star$. La chiusura solo transitiva sarà $A^+$.
\end{nota}

\subsubsection{Analisi degli automi a pila}\label{sec:automi-pila-analisi}

Come anche per gli FSA, è facile trovare un \hl{linguaggi non riconosciuti dagli
automi a pila}. Uno di questi è:

\begin{equation}
  L = \{ a^n b^n c^n \}\label{eqn:automi-pila-lang-non-ric}
\end{equation}

L'incapacità di riconoscere il linguaggio~\ref{eqn:automi-pila-lang-non-ric} può
essere ricondotta al fatto che \hl{la pila è una memoria distruttiva}: bisogna
distruggere ciò che ci è salvato dentro per leggerla (pop). \hl{Quanto appena
detto si dimostra con una estensione al Pumping lemma}. Noi non la tratteremo.

Studiamo ora la chiusura della famiglia dei linguaggi riconosciuti da un automa
a pila. Prendiamo due linguaggi $L_1 = \{ a^n b^n \}, L_2 = \{ a^n b^{2n} \}$.
Essi sono individualmente riconosciuti dagli automi a pila, la loro unione però
non lo è (ovviamente si può dimostrare). Ciò ci indica che \hl{la famiglia dei
linguaggi riconosciuti dagli automi a pila non è chiusa rispetto all'unione e
(per motivi analoghi) neanche rispetto all'intersezione}. Per quanto riguarda
invece il \hl{complemento}? Usiamo la \hl{stessa idea degli automi a stati
finiti}: scambiamo gli stati di accettazione con quelli di non accettazione.
Anche in questo caso \hl{$\delta$ va ``completata'' cercando di evitare di
cadere nel non-determinismo}. Le \hl{$\epsilon$-mosse possono ancora causare
problemi}:

\begin{itemize}
  \item Si può creare un \hl{ciclo di $\epsilon$-mosse} che fa entrare l'automa
    in blocco
  \item Può esserci una \hl{sequenza di $\epsilon$-mosse in cui si alternano
    stati di accettazione e di non accettazione}
\end{itemize}

In entrambi i casi \hl{si possono costruire automi equivalenti che eliminano
questi problemi}, nel primo caso eliminando i cicli, nel secondo forzando
l'accettazione alla fine di una sequenza di $\epsilon$-mosse.

\subsection{Macchine di Turing}\label{sec:macchine-turing}

L'ultimo automa che tratteremo sarà la macchina di Turing. Partiamo dalla
\hl{versione a $k$-nastri}, un po' più semplice di quella originaria, ma che
gode delle stesse proprietà.

Come indica il nome, la macchina di Turing a $k$-nastri è \hl{analoga a un
automa a stati finiti al quale aggiungiamo $k$ nastri di memoria}. Le
\hl{testine dei nastri possono muoversi in ambo le direzioni} arbitrariamente.
Come anche per gli altri automi avremo i \hl{soliti stati e alfabeti}. Per
convenzione storica, \hl{i nastri sono rappresentati da sequenze infinite di
celle} invece che da stringhe finite. Per rappresentare una \hl{cella
inutilizzata} usiamo il simbolo speciale \hl{``blank''}, rappresentato da
\hl{uno spazio vuoto, $\_$ o $\not{b}$}. Assumeremo che ogni nastro \hl{contenga
solo un numero finito di celle non contenenti blank}. Come nel caso degli automi
a pila indichiamo \hl{l'inizio del nastro con $Z_0$}.

La mossa della macchina di Turing è simile a quella dell'automa a pila ma un po'
più articolata. Possiamo suddividerla in \hl{due ``fasi''}:

\begin{enumerate}
  \item \hl{Lettura}
    \begin{itemize}
      \item \hl{Legge} il carattere in corrispondenza della testina del
        \hl{nastro d'ingresso}
      \item \hl{Legge} i $k$ caratteri dai \hl{nastri}
      \item Valuta lo \hl{stato} dell'organo di controllo
    \end{itemize}
  \item \hl{Scrittura}
    \begin{itemize}
      \item Cambia \hl{stato}
      \item \hl{Scrittura} di un carattere sui \hl{nastri di memoria}
      \item Eventuale \hl{scrittura} di un carattere sul \hl{nastro di uscita}
      \item \hl{Spostamento delle testine} di una posizione
    \end{itemize}
\end{enumerate}

Introduciamo anche la \hl{nuova notazione per le transizioni} (tra parentesi è
riportata la parte aggiuntiva nel caso di presenza di output):

\[
  \mhl{
  i, \langle A_1, \ldots, A_k \rangle/(o),
    \langle A'_1, \ldots, A'_k \rangle,
    \langle M_0, \ldots, M_k, (M_{k+1}) \rangle
  }
\]

\begin{itemize}
  \item $i$: carattere letto dal nastro di ingresso
  \item $\langle A_1, \ldots, A_k \rangle$: le letture dai vari nastri
  \item $o$: il carattere scritto sul nastro di uscita
  \item $\langle A'_1, \ldots, A'_k \rangle$: le scritture sui vari nastri
  \item $\langle M_0, \ldots, M_k, (M_{k+1}) \rangle$: i movimenti effettuati
    dai vari nastri dove:
    \begin{itemize}
      \item $M_0$ è il movimento della testina di ingresso
      \item $M_{k+1}$ è il movimento della testina di output
    \end{itemize}
\end{itemize}

Le nuove funzioni di transizione e traduzioni saranno le seguenti:

\begin{align}
  \delta&: Q \times I \times \Gamma^k \to
    Q \times \Gamma^k \times {\{R,L,S\}}^{k+1} \\
  \eta&: Q \times I \times \Gamma^k \to
    Q \times \Gamma^k \times {\{R,L,S\}}^{k+1} \times O \times \{R,S\}
\end{align}

Lo \hl{stato iniziale} di una macchina di Turing è \hl{come ce lo
immagineremmo}: $Z_0$ seguito da blank nei nastri, uscita tutta blank, testine
in posizione 0 per ogni nastro, organo di controllo nello stato iniziale e
stringa iniziale scritta sul nastro iniziale a partire dalla posizione 0 seguita
da blank. \hl{Le condizioni di terminazione, e quindi di accettazione, sono
leggermente diverse da quelle viste fino ad ora}:

\begin{itemize}
  \item Gli \hl{stati di accettazione} sono sempre \hl{$F \subseteq Q$}
  \item Per convenzione la \hl{$\delta (\eta)$ non è definita a partire dagli
    stati finali}:

    \[
      \forall q \in F \delta(q, \ldots) = \bot (\eta (q, \ldots) = \bot)
    \]

  \item La macchina si \hl{ferma in uno stato $q$ quando
    $\delta(q, \ldots) = \bot$}
  \item La stringa in ingresso è \hl{accettata se e solo se dopo un numero
    finito di transizioni la macchina si ferma in uno stato di accettazione}
\end{itemize}

Ciò significa che una stringa in ingresso non è accettata se la macchina si
ferma in uno stato di accettazione o se la macchina non si ferma.

\subsubsection{Proprietà di chiusura delle macchine di Turing}\label{sec:analisi-mt}

La famiglia dei linguaggi riconosciuti dalle macchine di Turing è \hl{chiusa}
per:

\begin{itemize}
  \item \hl{$\cup$} simulazione di \hl{esecuzione ``in parallelo''}
  \item \hl{$\cap$} simulazione di \hl{esecuzione ``in serie''}
  \item \hl{$ . $} simile a $\cap$
  \item \hl{$\star$} come concatenazione
\end{itemize}

Per quanto riguarda il \hl{complemento} la situazione è diversa. Il principale
problema sta nel fatto che \hl{non esistono macchine di Turing loop-free}, ossia
macchine di Turing equivalenti ad una data ma con eventuali cicli rimossi (come
si poteva fare per PDA e FSA). A causa di ciò il \hl{rischio di generare
computazioni infinite} non è eliminabile. La \hl{dimostrazione} di ciò verrà
vista in seguito nella \hl{parte di computabilità del corso}.

\subsubsection{Modelli equivalenti di macchine di Turing}\label{sec:modelli-mt}

Noi abbiamo introdotto il modello della macchina di Turing a $k$ nastri. \hl{Si
può dimostrare, però, che esistono diverse formulazioni equivalenti della
macchina di Turing. Queste diverse tipologie di macchina sono funzionalmente
equivalenti, con unica differenza la complessità dell'organo di controllo.}

\paragraph{MT a singolo nastro} Il primo modello, e anche il \hl{più
vecchio}, che enunceremo è quello della MT a singolo nastro. Essa, come implica
il nome, \hl{possiede un singolo nastro di memoria infinito sul quale la testina
si può muovere in entrambe le direzioni}. Questo unico nastro \hl{viene usato
come memoria, input ed eventualmente output}. Attenzione a \hl{non confonderla
con la MT con $k=1$ nastri} (chiamata ``ad un nastro di memoria'').

\paragraph{MT con nastro di memoria bidimensionale} Un altro modello
interessante è quello in cui il \hl{nastro di memoria è organizzato come una
tabella e la testina si può muovere in entrambe e 4 le direzioni cardinali
sequenzialmente}. Si ricorda che l'accesso randomico alla memoria non è
possibile con una semplice MT\@.

\paragraph{Macchine di von Neumann} La macchina di von Neumann è il
\hl{modello astratto di un computer con processore, memoria ad accesso randomico
e periferiche}. Le macchine di Turing \hl{possono simulare anche questo modello}
già più complesso. Il \hl{risultato} però è una macchina \hl{molto più complessa
e lenta}. Ciò vale in generale: \hl{si possono costruire modelli più prestanti e
complessi della macchina di Turing, ma essi non ne aumentano la capacità
espressiva}.

\subsection{Modelli operazionali non deterministici}\label{sec:modelli-non-det}

I modelli visti \hl{fino ad ora} sono detti \hl{deterministici}: \hl{in un certo
stato e con certi ingressi la mossa eseguita è sempre la stessa}. Se
\hl{neghiamo questa ipotesi} creiamo dei \hl{modelli} detti \hl{non
deterministici}. Ciò significa che \hl{per un certo stato l'automa potrà
eseguire più mosse diverse ed è lui a scegliere quale di queste eseguire}. Si
vengono a \hl{creare}, quindi, dei \hl{fili (thread) di esecuzione che l'automa
può seguire}. Il modello dell'esecuzione di un automa non deterministico può
visto come:

\begin{description}
  \item[Parallelo] L'automa esegue \hl{tutte le strade contemporaneamente}.
    L'automa si ferma quando tutti le fili di esecuzione hanno terminato o per
    esaurimento dell'input o per la parzialità delle funzione di transizione.
  \item[Sequenziale] L'automa \hl{esegue solo un filo, ma ad ogni biforcazione
    sceglie uno dei fili di esecuzione in modo casuale}.
\end{description}

Di solito i modelli non deterministici \hl{tendono ad essere più compatti
sacrificando l'operatività}. In un \hl{contesto pratico} essi possono essere
\hl{realizzati utilizzando più esecutori, seguendo il modello parallelo}.
Vediamo le varianti non deterministiche dei modelli già noti.

\subsubsection{Automi a stati finiti non deterministici}\label{sec:nfa}

Iniziamo con il primo modello, e il più semplice gli automi a stati finiti non
deterministici o NFA (``nondeterministic finite automata''). Diciamo che un
\hl{FSA è non deterministico se esiste $\delta(q, a) = \{q_1, q_2\}$} ossia
\hl{associati ad uno stato e ad un carattere è associato un insieme di
transizioni}. Sarà quindi necessario \hl{ridefinire $\delta$ e $\delta^\star$}.

\begin{gather}
  \mhl{ \delta: \; Q \times I \to \wp(Q) } \\
  \mhl{
    \delta^\star(q,x) =
    \begin{cases}
      \delta^\star(q, \epsilon) = \{q\} & x = \epsilon \\
      \delta^\star(q, y.i) = \bigcup_{q' \in \delta^\star(q, y)} \delta(q', i) &
        x=y.i, i \in I
    \end{cases}
  }
\end{gather}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0)  []                                  {$q_0$};
    \node[state]           (q1)  [above right of=q0, yshift=-0.25cm] {$q_1$};
    \node[state,accepting] (q11) [above right of=q1, yshift=-1cm]    {$q_{11}$};
    \node[state]           (q12) [below right of=q1, yshift=+1cm]    {$q_{12}$};
    \node[state]           (q2)  [below right of=q0, yshift=+0.25cm] {$q_2$};
    \node[state,accepting] (q21) [above right of=q2, yshift=-1cm]    {$q_{21}$};
    \node[state]           (q22) [below right of=q2, yshift=+1cm]    {$q_{22}$};

    \path[->]
    (q0) edge node {$a$} (q1)
    (q1) edge node {$a$} (q11)
    (q1) edge node {$a$} (q12)
    (q0) edge node {$a$} (q2)
    (q2) edge node {$b$} (q21)
    (q2) edge node {$a$} (q22);
  \end{tikzpicture}
  \caption{Un esempio di NFA}\label{fig:nfa}
\end{figure}

Una \hl{stringa $x \in L$ appartiene al linguaggio modellato} da un NFA se:

\begin{equation}
  \mhl{ \delta^\star(q_0, x) \cap F \neq \emptyset }
\end{equation}

Ossia c'è \hl{almeno una sequenza di mosse che ci porta allo stato finale}. È
possibile anche considerare $\delta^\star(q_0, x) \subseteq F$.

È importante sottolineare che \hl{gli NFA non possiedono un potere riconoscitivo
maggiore dei semplici FSA}\@. Infatti \hl{possiamo sempre sintetizzare un FSA
equivalente ad uno non deterministico}. Intuitivamente, possiamo trasformare un
automa non deterministico in uno deterministico \hl{semplicemente unendo in un
singolo stato l'insieme di arrivo della $\delta$ e mantenendo gli archi}.
Possiamo anche operare nell'altro senso, ossia costruire un automa non
deterministico a partire da uno deterministico.

\subsubsection{Automi a pila non deterministici}\label{sec:npda}

Seguendo l'evoluzione svolta nella parte che tratta gli automi deterministici,
introduciamo gli automi a pila non deterministici o NPDA\@. Il concetto di \hl{non
determinismo è analogo a quello trattato in}~\ref{sec:nfa}. L'avevamo \hl{già
incontrato quando avevamo parlato delle $\epsilon$-mosse}. La nuova funzione di
transizione è:

\begin{equation}
  \mhl{
    \delta: Q \times (I \cup \{\epsilon\}) \times \Gamma \to
      \wp_f(Q \times \Gamma^\star)
  }
\end{equation}

Il \hl{pedice $f$} dell'insieme delle parti sta per \hl{``finito''}. Infatti i possibili
sottoinsiemi di $Q \times \Gamma^\star$ sono infiniti, ma noi \hl{consideriamo
solamente quelli ottenibili nell'immagine di $\delta$, ottenendo un insieme
delle parti finito}. Un \hl{NPDA accetta se} esiste una sequenza di mosse tale che:

\begin{equation}
  \mhl{
    c_0 \vdash^\star \{c_0, \ldots, c_n \}, \quad
      c_0 = \langle q_0, \epsilon, Z_0 \rangle,
      c_1 = \langle q, \epsilon, \gamma \rangle, \ldots, q \in F
  }
\end{equation}

\hl{Quindi la relazione $\vdash$ non è più univoca!}

Una \hl{semplice costruzione} come quella in \hl{figura}~\ref{fig:npda-unione}
ci permette di \hl{costruire sempre l'unione di due NPDA} e quindi di
\hl{dimostrare la chiusura degli NPDA rispetto all'unione}. Questa \hl{proprietà
non è condivisa dagli PDA}\@. Gli \hl{NPDA non sono, però, chiusi rispetto
all'intersezione}. Ciò implica che gli NPDA hanno un potere riconoscitivo
maggiore della controparte deterministica.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0)  []             {$q_0$};
    \node[state]           (q01) [above of=q0]  {$q_0'$};
    \node[state]           (q11) [right of=q01] {$q_1'$};
    \node[state]           (q21) [right of=q11] {$q_2'$};
    \node[state,accepting] (qf)  [right of=q21] {$q_f$};
    \node[state]           (q02) [below of=q0]  {$q_0''$};
    \node[state]           (q12) [right of=q02] {$q_1''$};
    \node[state]           (q22) [right of=q12] {$q_2''$};
    \node[state]           (q32) [right of=q22] {$q_3''$};

    \path[->]
    (q0)  edge []           node {$\epsilon,Z_0/Z_0$}      (q01)
    (q01) edge []           node {$a,Z_0/Z_0A$}            (q11)
    (q11) edge [loop above] node {$a,A/AA$}                ()
    (q11) edge []           node {$b,A/\epsilon$}          (q21)
    (q21) edge []           node {$\epsilon,Z_0/\epsilon$} (qf)
    (q21) edge [loop above] node {$b,A/\epsilon$}          ()
    (q0)  edge []           node {$\epsilon,Z_0/Z_0$}      (q02)
    (q02) edge []           node {$a,Z_0/Z_0A$}            (q12)
    (q12) edge []           node {$b,A/A$}                 (q22)
    (q12) edge [loop above] node {$a,A/AA$}                ()
    (q22) edge [bend left]  node {$b,A/\epsilon$}          (q32)
    (q32) edge []           node {$b,A/A$}                 (q22)
    (q32) edge []           node {$\epsilon,Z_0/\epsilon$} (qf);
  \end{tikzpicture}
  \caption{NPDA unione di due PDA\@. Lo NPDA riconosce $L = \{a^n b^n\} \cup
  \{a^n b^{2n}\}$. Da notare \hl{la $\epsilon$-mossa non deterministica che
  parte da $q_0$ e lega i due automi}, ognuno corrispondente ad uno dei due
  rami}%
  \label{fig:npda-unione}
\end{figure}

Se la famiglia dei linguaggi riconosciuti dagli NPDA è \hl{chiusa rispetto a
$\cup$ ma non rispetto a $\cap$ non può esserlo rispetto al complemento a causa
delle leggi di De Morgan}.

Proviamo a dimostrare il risultato sopra. Procedendo con le \hl{stesse modalità
del caso deterministico}, possiamo ottenere una \hl{computazione che termina e
accetta il linguaggio complemento}. Se però \hl{consideriamo} il caso:

\[
  \langle q_0, x, z_0 \rangle = c_0 \vdash^\star \{
    \langle q_1, \epsilon, \gamma_1 \rangle,
    \langle q_2, \epsilon, \gamma_2 \rangle \}, \mhl{ q_1 \in F, q_2 \notin F }
\]

La stringa \hl{$x$ è accettata anche se scambio $F$ con $Q \setminus F$},
rendendo impossibile la costruzione del complemento.

\subsubsection{Macchine di Turing non deterministiche}\label{sec:ntm}

Definiamo il concetto di \hl{non determinismo} in una macchina di Turing in modo
\hl{analogo ai casi precedenti}, ossia la capacità di poter \hl{assumere diversi
stati contemporaneamente}. Definiamo la relazione di \hl{transizione} per le NTM
(dall'inglese ``nondeterministic Turing machines''):

\begin{equation}
  \mhl{
    \delta : Q \times I \times \Gamma^k \to
      \wp(Q \times \Gamma^k \times \{ L,S,R \})
  }
\end{equation}

Non ripeteremo la definizione di \hl{configurazione, transizione, sequenza di
transizioni e accettazioni} poiché la loro \hl{definizione è invariata}.

Come nel caso degli NFA, le \hl{NTM non aggiungono capacità riconoscitiva}. Per
dimostrare ciò, costruiamo un \hl{algoritmo che permetta ad una macchina di
Turing deterministica di emulare il comportamento di una non deterministica}.
Poiché una stringa è accettata da una NTM solo se esiste un calcolo che termina
in uno stato di accettazione, rappresentiamo la \hl{computazione sotto forma di
un albero chiamato appunto albero delle computazioni}.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=1cm and 3cm,every node/.style={scale=1.3}]
    \node[] (c0)  [] {$c_0$};
    \node[] (cx)  [below left=of c0] {$c_x$};
    \node[] (cy)  [below=of c0] {$c_y$};
    \node[] (cz)  [below right=of c0] {$c_z$};
    \node[] (cb)  [below right=of cx, xshift=-2.0cm] {\color{red}$c_b$};
    \node[] (cx2) [below=of cx] {$c_x$};
    \node[] (cd)  [below left=of cx, xshift=+2.0cm] {\color{ForestGreen}$c_d$};
    \node[] (cxi) [below=of cx2] {};
    \node[] (ce)  [below=of cy] {$c_e$};
    \node[] (cyi) [below right=of cy, xshift=-2.0cm] {};
    \node[] (cf)  [below right=of cz, xshift=-2.0cm] {\color{ForestGreen}$c_f$};
    \node[] (ca)  [below=of cz] {$c_a$};
    \node[] (ci)  [below left=of cz, xshift=+2.0cm] {\color{ForestGreen}$c_i$};
    \node[] (cf2) [below=of ce] {\color{ForestGreen}$c_f$};
    \node[] (cm)  [below=of ca] {\color{red}$c_m$};

    \path[->]
    (c0)  edge         (cx)
    (c0)  edge         (cy)
    (c0)  edge         (cz)
    (cx)  edge         (cb)
    (cx)  edge         (cx2)
    (cx)  edge         (cd)
    (cy)  edge         (ce)
    (cy)  edge[dotted] (cyi)
    (cz)  edge         (cf)
    (cz)  edge         (ca)
    (cz)  edge         (ci)
    (cx2) edge[dotted] (cxi)
    (ce)  edge         (cf2)
    (ca)  edge         (cm);
  \end{tikzpicture}
  \caption{Un esempio di albero delle computazioni. In verde sono indicati gli
  stati di accettazione, in rosso gli stati di non accettazione e con le linee
  tratteggiati i percorsi che porterebbero ad una computazione infinita.}%
  \label{fig:albero-computazioni}
\end{figure}

Per emulare una NTM con una MT ci \hl{basterà}, quindi, \hl{percorrere in
larghezza questo albero, scandendo le varie configurazioni finché non ne
troveremo una di accettazione}. Per eseguire questa operazione in alberi
tradizionali esistono degli algoritmi ben consolidati
\hl{(``breadth first search'')}.

\section{Le grammatiche}\label{sec:grammatiche}

Le grammatiche sono un \hl{altro tipo di modello che possiamo usare per
modellare i linguaggi}. A differenza degli automi, le grammatiche sono un
\hl{modello generativo} più che riconoscitivo. Una automa, infatti, legge una
stringa in ingresso, la elabora e determina se appartiene al linguaggio; una
grammatica, invece, \hl{descrive una serie di regole per generare le stringhe
del linguaggio}.

Come anticipato, possiamo \hl{intuitivamente definire le grammatiche come un
insieme di regole usato per costruire le ``frasi''}, sinonimo di stringhe,
\hl{del linguaggio} di interesse. In modo \hl{analogo alle grammatiche dei
normali meccanismi linguistici}, una grammatica formale \hl{genera le stringe}
di un linguaggio attraverso un \hl{processo di riscrittura}. Esse \hl{descrivono
un oggetto principale} (la frase) come un \hl{insieme ordinato di componenti, a
loro volta descritti come composti da altri componenti fino ad arrivare agli
elementi fondamentali dell'alfabeto considerato}.

\end{document}
