\documentclass[a4paper,11pt,oneside]{article}

\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}

\usepackage[bookmarks,colorlinks]{hyperref}
\usepackage{enumerate}
\usepackage[dvipsnames]{xcolor}
\usepackage{soulutf8}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}

\definecolor{hlcolor}{RGB}{253,241,98}
\sethlcolor{hlcolor}

\theoremstyle{plain}
\newtheorem{lem}{Lemma}[section]
\newtheorem{prop}{Proposizione}[section]
\newtheorem{thm}{Teorema}[section]

\theoremstyle{definition}
\newtheorem{defn}{Definizione}[section]

\theoremstyle{remark}
\newtheorem*{esempio}{Esempio}
\newtheorem*{nota}{Nota}

\newcommand{\mhl}[1]{\colorbox{hlcolor}{$\displaystyle #1$}}

\title{Appunti di ``Algoritmi e Principi dell'informatica''}
\author{Alexandru Gabriel Bradatan}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduzione ai modelli}\label{sec:modelli}

I modelli sono fondamentali nell'ingegneria. I modelli sono talvolta fisici e
spesso sono \hl{modelli formali, ossia oggetti matematici che fungono da
rappresentazioni astratte di entità reali complesse.} Un modello è \hl{adeguato
se i risultati ottenuti riflettono le proprietà che ci interessano del sistema
fisico entro i limiti della nostra approssimazione.} I modelli dell'informatica
si basano principalmente sulla matematica discreta. Definiamo i due tipi di
modelli che costruiremo.

\begin{defn}[\hl{Modello operazionale}]\label{def:modello-op}
  È un modello basato sul concetto di stato e di meccanismo per la sua
  evoluzione.
\end{defn}

\begin{defn}[\hl{Modello descrittivo}]\label{def:modello-desc}
  È un modello che formula le proprietà desiderate o no dal sistema piuttosto
  che il suo funzionamento.
\end{defn}

\hl{Le differenze tra questi due tipi di modellizzazione non sono spesso molto
ben definite.}

\begin{esempio}
  Modellizziamo lo stesso problema, l'ordinamento di una sequenza di interi,
  secondo i due criteri enunciati sopra:
  \begin{itemize}
    \item Modello operazionale: Calcola il minimo in tutto l'array e mettilo al
      primo posto. Continua ad eseguire l'operazione finché l'array non è in
      ordine.
    \item Modello descrittivo: Individua una permutazione degli elementi
      dell'array tale che \(\forall i a[i] \leq a[i+1]\).
  \end{itemize}
\end{esempio}

\hl{Le fasi dell'ingegneria del software ricalcano quelli della modellizzazione
di un problema:}

\begin{itemize}
  \item Analisi dei requisiti: Stesura della specifica del sistema
  \item Progetto: Architettura del software
  \item Implementazione: Scrittura effettiva del codice
\end{itemize}

\section{I linguaggi}\label{sec:linguaggi}

Il \hl{meta-modello fondamentale che useremo sarà il linguaggio}. Il termine
linguaggio è un termine che conosciamo già ed è utilizzabile a diversi ambiti
diversi come la linguistica, l'informatica, la grafica e la musica.

\subsection{Costruzione di un linguaggio}\label{sec:linguaggi-costruzione}

Iniziamo a definire i vari elementi un linguaggio. Il \hl{primo elemento formale
di un linguaggio è l'alfabeto o vocabolario}. In matematica essi sono sinonimi
anche se in italiano naturale non lo sono.

\begin{defn}[\hl{Alfabeto}]\label{def:alfabeto}
  Si dice alfabeto un insieme finito $A$ di simboli base.
\end{defn}

Una volta definito il concetto di alfabeto possiamo anche definire il concetto
di \hl{stringa}.

\begin{defn}[\hl{Stringa}]\label{def:stringa}
  Si dice stringa una sequenza ordinata e finita di elementi dell'alfabeto $A$.
\end{defn}

Naturalmente ogni stringa possiede una \hl{lunghezza $|a|$ pari al numero di
elementi dell'alfabeto contenuti al suo interno}. Definiamo anche la \hl{stringa
nulla $\epsilon$ tale che $|\epsilon|=0$}. Definiamo infine \hl{$A^\star$
l'insieme di tutte le stringhe scrivibili con un certo alfabeto}.

\begin{nota}
  L'operatore \hl{$\star$ è detto stella, star, iterazione o stella di Kleene.}
  L'insieme $A^\star$ è infinito numerabile.
\end{nota}

Sulle stringhe possiamo definire l'operazione di \hl{concatenazione}:

\begin{defn}[\hl{Concatenazione di stringhe}]\label{def:concatenazione-stringhe}
  \begin{equation}
    \begin{array}{cccc}
      . : & A^\star \times A^\star & \to & A^\star \\
          & (x, y) & \mapsto & x.y
    \end{array}
  \end{equation}
\end{defn}

\begin{nota}
  La scrittura dell'operatore di concatenazione può essere omessa, scrivendo al
  posto di $z = x.y$ $z = xy$.
\end{nota}

L'operazione di concatenazione gode della proprietà \hl{associativa ma non della
commutativa} e ha come \hl{elemento neutro la stringa vuota}. Possiamo quindi
definire il \hl{monoide non commutativo delle stringhe rispetto alla
concatenazione $\langle A^\star, . \rangle$}.

Definito tutti questi elementi possiamo finalmente definire un \hl{linguaggio}.

\begin{defn}[\hl{Linguaggio}]\label{def:linguaggio}
  Chiamiamo un linguaggio un insieme $L$ tale che: $L \subseteq A^\star$.
\end{defn}

Notiamo che \hl{$L$ può anche essere infinito}. Inoltre, poiché $L$ è un
insieme, le \hl{operazioni insiemistiche sono tutte ben definite.} Un
\hl{insieme di linguaggi che condividono le stesso proprietà è detto famiglia di
linguaggi}.

\subsection{Operazioni sui linguaggi}

\begin{defn}[\hl{Concatenazione di linguaggi}]\label{def:concatenazione-ling}
  \begin{equation}
    L_1 . L_2 = \{ x.y : x \in L_1, y \in L_2 \}
  \end{equation}
\end{defn}

\begin{defn}[\hl{Potenze di linguaggi}]\label{def:potenze-linguaggi}
  \begin{equation}
    \begin{aligned}
      L^0 & = \{\epsilon\} \\
      L^i & = L^{i-1}.L
    \end{aligned}
  \end{equation}
\end{defn}

\begin{defn}[\hl{Star (Linguaggi)}]\label{def:star-linguaggi}
  \begin{equation}
    L^\star = \bigcup^{\infty}_{i=0} L^i
  \end{equation}
\end{defn}

\begin{defn}[\hl{Plus (Linguaggi)}]\label{def:plus-linguaggi}
  \begin{equation}
    L^+ = \bigcup^{\infty}_{i=1} L^i
  \end{equation}
\end{defn}

\begin{nota}
  La differenza tra scrivere $L^\star$ e $L^+$ è che in $L^+$ è assente il
  linguaggio vuoto!
\end{nota}

\subsection{A cosa utilizzeremo i linguaggi?}

Il nostro \hl{principale utilizzo del concetto di linguaggio sarà per definire
in maniera astratta il concetto di problema informatico}. Il nostro \hl{primo}
problema informatico sarà:

\begin{equation}
  \mhl{ x \in A^\star, L \subseteq A^\star \quad  x \in L? }
\end{equation}

Questa semplice questione è capace di modellizzare una grande varietà di
problemi diversi, scelti $A$ ed $L$ in modo adatto. Un \hl{secondo} problema sarà
quello di \hl{trovare una traduzione}, ossia una funzione così definita:

\begin{defn}[\hl{Traduzione}]\label{def:traduzione}
  \begin{equation}
    \begin{array}{cccc}
      \tau: & L_1 & \to     & L_2 \\
            & x   & \mapsto & \tau(x)
    \end{array}
  \end{equation}
\end{defn}

\section{Modelli operazionali}\label{sec:modelli-operazionali}

\subsection{Automi a stati finiti}\label{sec:fsa}

Gli \hl{automi a stati finiti (FSA) sono il modello operazionale più semplice}.
Essi sono caratterizzati da un \hl{insieme finito di stati e da un insieme di
regole di transizione}. Gli \hl{stati} possono essere di \hl{accettazione o no}.
Le \hl{regole di transizione permettono al nostro automa di passare da uno stato
all'altro in base a ciò che forniamo come input}. Quando un automa riceve un
\hl{input lo elabora e produce un output. L'elaborazione inizia in uno stato
iniziale e consiste nel leggere l'input e spostarsi da uno stato all'altro
secondo le leggi di transizione}. \hl{Se alla fine} della lettura l'automa
\hl{si trova in uno stato di accettazione, diremo che esso ha accettato l'input,
altrimenti diremo che l'ha rifiutato}.

\begin{defn}[\hl{Automa a stati finiti}]\label{def:fsa}
  Un automa a stati finiti $\mathcal{A}$ è una quintupla
  $\langle Q, I, \delta, q_0, F \rangle$ dove:
  \begin{enumerate}
    \item $Q$ è l'insieme finito non vuoto di tutti gli stati
    \item $I$ è l'alfabeto di ingresso
    \item $\delta: Q \times I \to Q$ è la funzione (relazione) di transizione
    \item $q_0 \in Q$ è lo stato iniziale
    \item $F \subseteq Q$ è l'insieme degli stati di accettazione
  \end{enumerate}
\end{defn}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial,accepting]  (q0)                {$q_0$};
    \node[state]                    (q1) [right of=q0]  {$q_1$};

    \path[->]
    (q0) edge                node {0,1}  (q1)
    (q1) edge  [loop above]  node {0,1}  ();
  \end{tikzpicture}
  \caption{Esempio di diagramma di stato di FSA}\label{fig:fsa-diagramma-stato}
\end{figure}

Se \hl{$\delta$ è una funzione l'automa si dice completo, altrimenti non
completo}.  Gli \hl{automi non completi} possono facilmente \hl{resi completi
``riempiendo'' le transizioni mancanti con delle transizioni verso uno stato di
``sink'' dal quale non si può più uscire}.

Un automa \hl{processa l'input tramite una sequenza di transizioni di stato
effettuate iterando su ogni carattere della stringa e muovendosi allo stato
corrispondente a $\delta(q, i)$}. Definiamo formalmente la sequenza di mosse
eseguita da un automa a stati finiti.

\begin{defn}[\hl{Sequenza di mosse}]\label{def:fsa-seq-mosse}
  Sia un FSA $\mathcal{A}$, la sequenza di mosse è una funzione

  \begin{equation}
    \delta^\star: Q \times I^\star \to Q
  \end{equation}

  Definita induttivamente da:

  \begin{enumerate}
    \item $\delta^\star(q, \epsilon) = q$
    \item $\delta^\star(q, y.i) = \delta(\delta^\star(q,y), i)$ con
      $y \in I^\star, i \in I$
  \end{enumerate}
\end{defn}

Gli \hl{FSA rappresentano dei linguaggi}, più nello specifico la famiglia dei
\hl{linguaggi regolari} ($\mathbf{REG}$). Se \hl{$L$ è un linguaggio accettato}
da $\mathcal{A}$ allora diremo che esso è il \hl{linguaggio di $\mathcal{A}$ e
lo indichiamo come $L(\mathcal{A})$}. Usando la definizione di \hl{sequenza di
mosse possiamo scrivere $L(\mathcal{A})$ come}:

\begin{equation}
  L(\mathcal{A}) = \{ x \in I^\star : \delta^\star(q_0, x) \in F \}
\end{equation}

Per \hl{rappresentare il linguaggio} accettato da un FSA possiamo usare la pura
notazione insiemistica oppure, visto che i linguaggi sono regolari, delle
\hl{espressioni regolari}. Definiamo la sintassi delle espressioni regolari.

\begin{defn}[Espressioni regolari]\label{def:regex}
  Dato una alfabeto $A$, siano le seguenti operazioni:

  \begin{itemize}
    \item $R + S = R \cup S$ con $R \subseteq A^\star$ e $S \subseteq A^\star$
    \item $\star$ la star di Kleene:
      $R^\star = \{x^n : n \in \mathbb{N}, x \in R\}$
    \item $R^+ = \{x^n : n \in \mathbb{N}^*, x \in R\}$
    \item la concatenazione: $RS = \{xy : x \in R, y \in S\}$
  \end{itemize}

  Allora, dato un alfabeto $A$ e un insieme di simboli
  $\{+,\star,(,),.,\emptyset\}$ si dice espressione regolare su $A$ la stringa
  $R \in A \cup \{+,\star,(,),.,\emptyset\}$ che rende vera una delle seguenti
  condizioni:

  \begin{enumerate}
    \item $R = \emptyset$
    \item $R \in A$
    \item $R = S + T$, $R = ST$, $R = S^\star$, $R = S^+$ con $S,T$ espressioni
      regolari su $A$
  \end{enumerate}
\end{defn}

Gli \hl{automi a stato finito sono modelli di calcolo con una memoria finita
pari al numero di stati}. Infatti \hl{ogni stato} rappresenta una \hl{istantanea
della situazione in cui si trova il sistema in un dato istante}. Il fatto di
\hl{possedere una memoria finita}, come vedremo in~\ref{sec:fsa-analisi}, è uno
degli \hl{aspetti più limitanti} degli automi a stato finito e ci costringeranno
a costruire modelli più sofisticati.

\subsubsection{Automi a stati finiti traduttori}\label{sec:fsa-trad}

Un FSA può anche essere \hl{usato come traduttore tra un linguaggio ed un
altro}. Ci basta \hl{aggiungere la capacità di dare un output} al nostro automa.

Un semplice FSA si limita semplicemente ad interpretare un input senza produrre
nessun output. Se ad un \hl{FSA} aggiungiamo la possibilità di \hl{produrre un
output} otteniamo un \hl{trasduttore}. Un \hl{particolare tipo} di trasduttore
che ci interessa è il \hl{traduttore}.

Prima di parlare di traduttori, però, formalizziamo come un automa produce un
output.

\begin{defn}[\hl{Funzione di transizione con uscita}]\label{def:fsa-transizione-uscita}
  Chiamiamo $\delta(q, i/w)$ con $i \in I$ e $w \in O$, $I, O$ alfabeti, una
  funzione di transizione tra stati che restituisce il nuovo stato del FSA e
  un simbolo complesso $w$.
\end{defn}

Ora possiamo definire il traduttore.

\begin{defn}[\hl{Automa a stati finiti traduttore}]\label{def:fsa-trad}
  Sia $\mathcal{A} = \langle Q, I, \delta, q_0, F \rangle $ un automa a stati
  finiti con funzione di transizione $\delta(q, i/w)$, definiamo automa a
  stati finiti traduttore $\mathcal{T}$ la terna
  $\langle \mathcal{A}, O, \eta \rangle$ dove:

  \begin{itemize}
    \item $O$ è l'alfabeto di uscita di $\delta$
    \item $\eta : Q \times I \to O^\star$ funzione di traduzione
  \end{itemize}
\end{defn}

\hl{Analogamente a quanto fatto in}~\ref{def:fsa-seq-mosse} \hl{possiamo
iterare} la funzione di traduzione usando la stella di Kleene, così da \hl{poter
finalmente enunciare la traduzione come}:

\begin{equation}
  \mhl{\tau(x) = \eta^\star(q_0, x)}
\end{equation}

Se il \hl{traduttore conclude} la propria esecuzione \hl{su uno stato di
accettazione}, allora possiamo dire che la \hl{stringa di input e corretta e la
sua traduzione nel linguaggio di output è $\tau(x)$}.

\subsubsection{Analisi degli automi a stati finiti}\label{sec:fsa-analisi}

Gli automi a stati finiti sono un modello molto semplice ed intuitivo, applicato
a molti settori. Abbiamo già visto in~\ref{sec:fsa} che sono adatti a modellare
linguaggi regolari e che sono modelli a memoria finita. Studiamone ora nel
dettaglio le proprietà ed eventuali limitazioni.

Innanzitutto esiste qualche \hl{condizione affinché un automa a stati finiti sia
o no accettore di un linguaggi finito o infinito} (il caso di linguaggio vuoto è
banale)? Si dimostra che \hl{esistono} due condizioni \hl{necessarie e
sufficienti} per l'accettazione dei linguaggi, \hl{una per il caso finito e un
per l'infinito}.

\begin{thm}[\hl{Condizione di accettazione di un linguaggio finito}]\label{thm:accettazione-ling-finito}
  Condizione sufficiente e necessaria affinché un automa a stati finiti accetti
  un linguaggio finito non vuoto è che possa accettare una stringa di lunghezza
  inferiore al numero di stati ($|x| < |Q|$).
\end{thm}

\begin{thm}[\hl{Condizione di accettazione di un linguaggio infinito}]\label{thm:accettazione-ling-infinito}
  Condizione sufficiente e necessaria affinché un automa a stati finiti accetti
  un linguaggio infinito è che possa accettare una stringa tale che:
  $|Q| \leq |x| < 2|Q|$
\end{thm}

Questo teorema deriva dall'osservazione che \hl{se un automa accetta un
linguaggio infinito, nel suo grafo saranno presenti dei cicli che potranno
essere percorsi un numero arbitrario di volte}. Nel \hl{caso peggiore} verranno
\hl{ripercorsi tutti gli stati} dell'automa \hl{tranne l'ultimo} che deve essere
di accettazione.

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]            (q0)                {$q_0$};
    \node[state]                    (q1) [right of=q0]  {$q_1$};
    \node[state]                    (q2) [right of=q1]  {$q_2$};
    \node[state]                    (q3) [right of=q2]  {$q_3$};
    \node[state]                    (q4) [right of=q3]  {$q_4$};
    \node[state,accepting]          (q5) [right of=q4]  {$q_5$};

    \path[->]
    (q0) edge                node {} (q1)
    (q1) edge                node {} (q2)
    (q2) edge                node {} (q3)
    (q3) edge                node {} (q4)
    (q4) edge                node {} (q5)
    (q5) edge  [bend left]   node {} (q0);
  \end{tikzpicture}
  \caption{Peggior caso del teorema~\ref{thm:accettazione-ling-infinito}}\label{fig:fsa-accettazione-ling-infinito}
\end{figure}

Possiamo quindi vedere \hl{una stringa di un linguaggio infinito come composta
da 3 parti: un preambolo al ciclo, il ciclo e l'epilogo}. Il ciclo può ripetersi
un numero infinito di volte, generando la seguente espressione regolare:

\begin{equation}
  \mhl{x = x_i x_c^\star x_f}
\end{equation}

Questa è una \hl{condizione necessaria affinché una stringa di un linguaggio
infinito sia riconosciuta da un FSA} e rappresenta il \hl{contenuto del
``Pumping lemma''}:

\begin{lem}[\hl{Pumping lemma}]\label{thm:pumping-lemma}
  Sia un automa a stati finiti $\mathcal{A}$ che accetta un linguaggio
  $L(\mathcal{A})$. Allora per ogni $x \in L$ con $|x| > |Q|$ esiste $q \in Q$
  e $w \in I^+$ tali da verificare una di queste condizioni:

  \begin{itemize}
    \item $x = ywz$
    \item $\delta^\star(q,w) = q$
  \end{itemize}

  Come conseguenza si ha: $\forall n \in \mathbb{N} \geq 0, y w^n z \in L$
\end{lem}

Il Pumping lemma, quindi, ci \hl{mette dei paletti sui tipi di linguaggi
infiniti che un FSA può accettare}. Infatti consideriamo il seguente linguaggio
infinito:

\begin{equation}
  \mhl{L = \{ a^n b^n : n \in \mathbb{N} \}}
\end{equation}

\hl{Supponiamo} che un \hl{FSA sia in grado di accettarlo}, allora consideriamo
la stringa \hl{$x = a^m b^m$ con $m > |Q|$} e applichiamo il \hl{Pumping lemma}.
Otterremo \hl{3 casi possibili}:

\begin{enumerate}
  \item \hl{$w = a^p$} e quindi dovrebbe essere:
    \[
      \mhl{
      x = a^m b^m = a^r a^p a^s b^m = a^r w a^s b^m \in L \text{ con } r+p+s=m
    }
    \]
    \hl{Se il Pumping lemma dovesse valere}, allora si dovrebbe avere che
    \hl{$a^r w^k b^m \in L$} che ci porta ad un \hl{assurdo}.
  \item \hl{$w = b^p$ analogo al precedente}.
  \item \hl{$w = a^p b^q$} e quindi dovrebbe essere:
    \[
      \mhl{
      x = a^m b^m = a^r a^p b^q b^s = a^r w b^s \in L \text{ con } r+p=q+s=m
      }
    \]
    \hl{Se il Pumping lemma dovesse valere}, allora si dovrebbe avere che
    \hl{$a^r w^k b^s \in L$} che ci porta ad un \hl{assurdo}.
\end{enumerate}

Ciò significa che \hl{considerare $L$ come accettato da una FSA è un assurdo}.
Il linguaggio $L$ appena costruito ci dimostra quindi la necessità di costruire
modelli di calcolo più potenti. \hl{Infatti per contare fino a $n$ non basta la
memoria finita degli FSA ma servirebbe una memoria infinita!}

\subsubsection{Proprietà di chiusura degli automi a stati finiti}\label{sec:chiusura-fsa}

Il concetto di chiusura di un insieme rispetto ad un'operazione o proprietà è
un concetto già affrontato nel precedente corso di logica e algebra lineare. In
questo contesto ci occupiamo della \hl{chiusura della famiglia dei linguaggi
regolari}.

\hl{La famiglia dei linguaggi regolari è chiusa rispetto a tutte le operazioni
insiemistiche, alla concatenazione, alla star di Kleene e praticamente tutte le
altre viste fino ad ora.} Proviamo a costruirne qualcuno.

\paragraph{Intersezione} Proviamo a costruire l'intersezione di due automi. Il
risultato sarà un automa che \hl{accetta solo stringe solo stringhe accettate da
entrambi gli automi di partenza}. Dati i due automi di partenza:

\[
  \begin{aligned}
    A^1 &= \langle Q^1, I, \delta^1, q_0^1, F^1 \rangle \\
    A^2 &= \langle Q^2, I, \delta^2, q_0^2, F^2 \rangle
  \end{aligned}
\]

Possiamo scrivere l'automa intersezione come:

\begin{gather}
  \langle A^1, A^2 \rangle = \langle Q^1 \times Q^2, I, \delta,
    \langle q_0^1, q_0^2 \rangle, F^1 \times F^2 \rangle\label{eqn:automa-intersezione} \\
  \delta(\langle q^1, q^2 \rangle, i) = \langle \delta(q^1, i),
    \delta(q^2, i) \rangle
\end{gather}

Con una semplice induzione si può dimostrare che il linguaggio di un automa così
definito è $L(\langle A^1, A^2 \rangle) = L(A^1) \cap L(A^2)$.

\begin{figure}[htb]
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]   (q0) {$q_0$};
    \node[state]           (q1) [right of=q0] {$q_1$};
    \node[state]           (q2) [right of=q1] {$q_2$};
    \node[state,accepting] (q3) [right of=q2] {$q_3$};
    \node[] (t) [left=1.5cm of q0] {$A^1$:};

    \path[->]
      (q0) edge node {$b$} (q1)
      (q1) edge node {$a$} (q2)
      (q2) edge node {$a$} (q3);
  \end{tikzpicture}
  \begin{tikzpicture}[node distance=2cm,auto]
    \node[state,initial]   (p0) {$p_0$};
    \node[state]           (p1) [right of=p0] {$p_1$};
    \node[state]           (p2) [right of=p1] {$p_2$};
    \node[state,accepting] (p3) [right of=p2] {$p_3$};
    \node[] (t) [left=1.5cm of p0] {$A^2$:};

    \path[->]
      (p0) edge node {$b$} (p1)
      (p1) edge node {$a$} (p2)
      (p2) edge node {$a$} (p3);
  \end{tikzpicture}
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0) {$\langle q_0, p_0 \rangle$};
    \node[state]           (q1) [right of=q0] {$\langle q_1, p_1 \rangle$};
    \node[state]           (q2) [right of=q1] {$\langle q_2, p_2 \rangle$};
    \node[state,accepting] (q3) [right of=q2] {$\langle q_3, p_3 \rangle$};
    \node[] (t) [left=1.5cm of q0] {$\langle A^1, A^2 \rangle$:};

    \path[->]
      (q0) edge node {$b$} (q1)
      (q1) edge node {$a$} (q2)
      (q2) edge node {$a$} (q3);
  \end{tikzpicture}
  \centering
  \caption{Due automi e la loro intersezione}%
  \label{fig:esempio-automa-intersezione}
\end{figure}

\paragraph{Unione} Per l'unione il tutto funziona in \hl{modo analogo}. L'automa
risultante sarà un automa che \hl{accetterà stringhe accettate da almeno uno dei due
automi di partenza}. Eseguendo un procedimento simile a quello effettuato per
ottenere~\ref{eqn:automa-intersezione} abbiamo:

\begin{equation}
  \langle A^1, A^2 \rangle = \langle Q^1 \times Q^2, I, \delta,
    \langle q_0^1, q_0^2 \rangle, F^1 \times Q^2 \cup Q^1 \times F^2 \rangle
\end{equation}

Questo approccio presenta, però, un \hl{problema}: \hl{non funziona se l'automa
di partenza non è completo}. Con l'intersezione non avevamo problemi perché
l'automa intersezione accettava solo stringhe accettate da entrambi gli automi
iniziali, rimuovendo il problema della non completezza. Con l'unione invece
otterremo un automa che accetta anche quando uno degli automi iniziali non
accetta, rendendo problematico il caso di un errore dovuto alla parzialità della
funzione di transizione. \hl{Bisogna, quindi, ricordarsi di completare gli
automi aggiungendo eventuali stati di errore prima di eseguirne l'unione}.

\paragraph{Complemento} Per il complemento la situazione è \hl{analoga all'unione}:
anche qui dobbiamo stare attenti alla completezza dei due automi di partenza.
L'automa complemento sarà praticamente uguale all'automa di partenza, solo che
\hl{gli stati di accettazione ora saranno di non accettazione e viceversa}.

\begin{equation}
  \neg A = \langle Q, I, \delta, q_0, Q \setminus F \rangle
\end{equation}

\subsection{Automi a stati finiti con pila}

Arricchiamo ora i nostri automi a stati finiti con della \hl{memoria}. Questa
memoria sarà \hl{strutturata come una pila (stack)} di dimensione potenzialmente
illimitata. L'automa può \hl{manipolare la pila tramite le due operazioni
fondamentali} delle pile: \hl{push e pop}. Indicheremo convenzionalmente
\hl{l'inizio della pila con $Z_0$}.

A grandi linee, una \hl{mossa} dell'automa a pila è \hl{strutturata in diversi
passi}:

\begin{enumerate}
  \item \hl{Leggi un simbolo (o nulla) dall'input} (d'ora in poi lo chiameremo
    nastro d'ingresso)
  \item Esegui una \hl{pop di un elemento} dalla stack
  \item \hl{Cambia stato}
  \item Sposta di una posizione il puntatore del carattere corrente (la testina
    del nastro d'ingresso)
  \item Esegui una \hl{push di una serie di caratteri (anche nulla)}
  \item Se è un automa traduttore, \hl{scrivi una stringa (anche nulla)
    sull'output} (nastro d'uscita)
\end{enumerate}

Come per gli FSA, \hl{la stringa in ingresso viene riconosciuta se l'automa la
scandisce completamente e termina su uno stato di accettazione}. Lo stato della
\hl{pila non è rilevante}. Se l'automa è \hl{traduttore}, allora \hl{se accetta}
la stringa \hl{l'output corrisponde alla stringa tradotta, altrimenti} viene
detta \hl{indefinita} e lo indichiamo con \hl{$\tau(x) = \perp$}. In generale
useremo il simbolo $\perp$ anche con la funzione $\delta$ per indicare una
transizione indefinita.

Poiché le transizioni di stato sono più ricche di quelle degli FSA, dobbiamo
adottare una \hl{notazione ben definita per indicare le varie azioni compiute}:

\begin{equation}
  \mhl{a, A / B\ldots, c}
\end{equation}

\begin{itemize}
  \item \hl{$a$} il carattere \hl{letto in input}
  \item \hl{$A$} il carattere \hl{letto dalla pila tramite stack}
  \item \hl{$B\ldots$} i caratteri \hl{reinseriti nella pila} tramite la push
  \item \hl{$c$} il carattere \hl{scritto sull'output}
\end{itemize}

Nel caso in cui l'automa \hl{non leggesse nulla} dal nastro d'ingresso diciamo
che l'automa \hl{ha effettuato una $\epsilon$-mossa} e la indichiamo
\hl{riportando $\epsilon$ come carattere letto} dal nastro d'ingresso. Vale
\hl{lo stesso anche con il carattere della push}.

\begin{nota}
  Un automa a pila \hl{non può non leggere nessun carattere dalla pila!}
  Scrivere, quindi, \hl{$a, \epsilon/B$ è sbagliato}.
\end{nota}

\begin{figure}[htb]
  \centering
  \begin{tikzpicture}[node distance=3cm,auto]
    \node[state,initial]   (q0) []            {$q_0$};
    \node[state]           (q1) [right of=q0] {$q_1$};
    \node[state]           (q2) [right of=q1] {$q_2$};
    \node[state,accepting] (q3) [right of=q2] {$q_3$};

    \path[->]
    (q0) edge              node {$a, Z_0/Z_0 A$} (q1)
    (q1) edge [loop above] node {$a, A/AA$} ()
    (q1) edge              node {$b, A/\epsilon$} (q2)
    (q2) edge [loop above] node {$b, A/\epsilon$} ()
    (q2) edge              node {$\epsilon, Z_0/\epsilon$} (q3);
  \end{tikzpicture}
  \caption{Esempio di un automa a pila}%
  \label{fig:automa-pila}
\end{figure}

\end{document}
